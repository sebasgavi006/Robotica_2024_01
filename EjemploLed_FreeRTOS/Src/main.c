/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "FreeRTOS.h"
#include "task.h"


#include <stdint.h>
#include <stdio.h>

#include "gpio_driver_hal.h"

# define STACK_SIZE 200
// definicion de variables del sistema
uint32_t SystemCoreClock = 16000000;


/* Perifericos del sistema */
GPIO_Handler_t led_state = {0};
GPIO_Handler_t user_button = {0};

/* Declaramos algunas variables propias del FreeRTOS */
BaseType_t xReturned;
TaskHandle_t xHandlerTask_Blinky_Led = NULL;
TaskHandle_t xHandlerTask2 = NULL;

/*  Cabeceras de las funciones del programa */
void vTask_Blink_Led(void * pvParameters);
void vTaskTwo(void * pvParameters);
void initSystem(void);

/*
 * FUNCIÓN PRINCIPAL DEL PROGRAMA
 */
int main(void)
{

	/* Activamos la unidad de punto flotante (FPU) */
	SCB->CPACR    |= (0xF << 20);

	/* Activamos del contador de Ticks */
	DWT->CTRL    |= (1 << 0);

	/* Inicializamos el sistema */
	initSystem();

	/* Primero configuramos */
	SEGGER_SYSVIEW_Conf();
	/* Despues activamos el sistema */
	SEGGER_SYSVIEW_Start();


    xReturned = xTaskCreate(
                    vTask_Blink_Led,       		/* Function that implements the task. */
                    "Task-Blinky",        		/* Text name for the task. */
                    STACK_SIZE,      			/* Stack size in words, not bytes. */
                    ("Led parpadeando"),    	/* Parameter passed into the task. */
                    2,							/* Priority at which the task is created. */
                    &xHandlerTask_Blinky_Led );	/* Used to pass out the created task's handle. */

    configASSERT(xReturned == pdPASS);


    xReturned = xTaskCreate(
                    vTaskTwo,       			/* Function that implements the task. */
                    "Task-2",          			/* Text name for the task. */
                    STACK_SIZE,      			/* Stack size in words, not bytes. */
                    ("Hola mundo desde la Tarea-2"),	/* Parameter passed into the task. */
                    2,							/* Priority at which the task is created. */
                    &xHandlerTask2 );     		/* Used to pass out the created task's handle. */

    configASSERT(xReturned == pdPASS);

    //STart the created tasks running
    vTaskStartScheduler();

    /* Loop forever */
	while(1){
		// Si llegamos aqui algo salio mal
	}
}


/*
 * Funciones locales del main
 */

//Funcion que gobierna la tarea 1
void vTask_Blink_Led(void * pvParameters) {

	BaseType_t notify_state = {0};
	uint8_t change_state = 0;

	/*
	 * Todas las tareas contienen un loop infinito.
	 * Si la ejecución se sale del loop, algo salió mal.
	 */
	while(1){
		//printf("%s\n",(char*)pvParameters);


		// Si se recibe la notificación, se hace el blinky
		if(notify_state == pdTRUE){
			change_state = !change_state;
		}

		if(change_state){
			gpio_TooglePin(&led_state);
		}
		else{
			gpio_WritePin(&led_state, RESET);
		}
		//vTaskDelay( pdMS_TO_TICKS(250));
		notify_state = xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(250));
	}
}


//Funcion que gobierna la tarea 2
void vTaskTwo(void * pvParameters) {

	// Variables locales
	uint8_t button_state = 0;
	uint8_t prev_button_state = 0;


	while(1){

		//printf("%s\n",(char*)pvParameters);
		button_state = gpio_ReadPin(&user_button);

		// Se entra en todo el ciclo cuando se cumple que el botón se presiona y se deja de presionar
		if(button_state){
			if(!prev_button_state){

				// Esta función envía la notificación al Handler de la tarea que maneja del Blinky
				xTaskNotify(xHandlerTask_Blinky_Led, 0, eNoAction);
			}
		}
		prev_button_state = button_state;

		vTaskDelay(pdMS_TO_TICKS(10));
	}
}


// Funcion para inicializar el sistema+
void initSystem(void){

	// Configuramos el led de estado
	led_state.pGPIOx 						= GPIOA;
	led_state.pinConfig.GPIO_PinNumber		= PIN_5;
	led_state.pinConfig.GPIO_PinMode 		= GPIO_MODE_OUT;
	led_state.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_LOW;
	led_state.pinConfig.GPIO_PinOutputType 	= GPIO_OTYPE_PUSHPULL;
	led_state.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;

	// Cargamos la configuracion del pin led_state
	gpio_Config(&led_state);

	// Apagamos el led
	gpio_WritePin(&led_state, RESET);


	// Configuramos el led de estado
	user_button.pGPIOx 							= GPIOC;
	user_button.pinConfig.GPIO_PinNumber		= PIN_13;
	user_button.pinConfig.GPIO_PinMode 			= GPIO_MODE_IN;
	user_button.pinConfig.GPIO_PinPuPdControl 	= GPIO_PUPDR_NOTHING;

	// Cargamos la configuracion del pin led_state
	gpio_Config(&user_button);




}


